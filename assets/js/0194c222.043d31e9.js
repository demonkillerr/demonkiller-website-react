"use strict";(self.webpackChunkdemonkiller_portfolio=self.webpackChunkdemonkiller_portfolio||[]).push([[3962],{3632:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>i,toc:()=>t});const i=JSON.parse('{"id":"code/languages/C/dynamic_mem_alloc","title":"Dynamic Memory Allocation in C","description":"This document covers Dynamic Memory Allocation in C.","source":"@site/docs/code/languages/C/dynamic-mem-alloc.md","sourceDirName":"code/languages/C","slug":"/code/languages/C/dynamic_mem_alloc","permalink":"/docs/code/languages/C/dynamic_mem_alloc","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"Gaurang","lastUpdatedAt":1767628613000,"frontMatter":{"title":"Dynamic Memory Allocation in C","id":"dynamic_mem_alloc","sidebar_label":"Dynamic Memory"},"sidebar":"docs","previous":{"title":"Arrays of Pointers","permalink":"/docs/code/languages/C/arrays_of_pointers"},"next":{"title":"Strings","permalink":"/docs/code/languages/C/strings"}}');var a=l(4848),o=l(8453);const r={title:"Dynamic Memory Allocation in C",id:"dynamic_mem_alloc",sidebar_label:"Dynamic Memory"},s=void 0,c={},t=[{value:"Stack vs. Heap Memory",id:"stack-vs-heap-memory",level:2},{value:"Stack Memory",id:"stack-memory",level:3},{value:"Example",id:"example",level:4},{value:"Heap Memory",id:"heap-memory",level:3},{value:"Example:",id:"example-1",level:4},{value:"When to Use Dynamic vs. Static Allocation",id:"when-to-use-dynamic-vs-static-allocation",level:3},{value:"<strong>2.3 When to Use Dynamic vs. Static Allocation</strong>",id:"23-when-to-use-dynamic-vs-static-allocation",level:3},{value:"Memory Allocation Functions",id:"memory-allocation-functions",level:2},{value:"malloc() \u2013 Allocates Memory Without Initialization",id:"malloc--allocates-memory-without-initialization",level:3},{value:"calloc() \u2013 Allocates and Initializes Memory to Zero",id:"calloc--allocates-and-initializes-memory-to-zero",level:3},{value:"realloc() \u2013 Resizing Allocated Memory",id:"realloc--resizing-allocated-memory",level:3},{value:"free() \u2013 Deallocates Memory",id:"free--deallocates-memory",level:3},{value:"Best Practices for Memory Management",id:"best-practices-for-memory-management",level:2},{value:"Common Heap Memory Issues",id:"common-heap-memory-issues",level:2},{value:"Memory Leaks",id:"memory-leaks",level:3},{value:"Dangling Pointers",id:"dangling-pointers",level:3},{value:"Double Free",id:"double-free",level:3},{value:"Buffer Overflows",id:"buffer-overflows",level:3},{value:"Debugging Tools for Memory Management",id:"debugging-tools-for-memory-management",level:2},{value:"Using valgrind (Linux)",id:"using-valgrind-linux",level:3},{value:"Using Address Sanitizer (GCC/Clang)",id:"using-address-sanitizer-gccclang",level:3}];function d(e){const n={admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"This document covers Dynamic Memory Allocation in C."}),"\n",(0,a.jsx)(n.p,{children:"C provides powerful memory management capabilities through dynamic memory allocation, allowing programs to allocate and free memory at runtime. Unlike static memory allocation, where memory size is fixed at compile time, dynamic allocation allows flexible memory management."}),"\n",(0,a.jsx)(n.p,{children:"In this section, we will cover:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Difference Between Stack and Heap Memory"}),"\n",(0,a.jsx)(n.li,{children:"When to Use Dynamic Allocation vs. Static Allocation"}),"\n",(0,a.jsx)(n.li,{children:"Memory Allocation Functions (malloc, calloc, realloc, free)"}),"\n",(0,a.jsx)(n.li,{children:"Best Practices for Memory Management"}),"\n",(0,a.jsx)(n.li,{children:"Common Heap Memory Issues (Memory Leaks, Dangling Pointers, etc.)"}),"\n",(0,a.jsx)(n.li,{children:"Debugging Tools for Heap Memory Management"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"stack-vs-heap-memory",children:"Stack vs. Heap Memory"}),"\n",(0,a.jsx)(n.h3,{id:"stack-memory",children:"Stack Memory"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Automatically managed by the compiler."}),"\n",(0,a.jsx)(n.li,{children:"Used for local variables and function calls."}),"\n",(0,a.jsx)(n.li,{children:"Limited size (stack overflow if exceeded)."}),"\n",(0,a.jsx)(n.li,{children:"Fast allocation/deallocation."}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"void func() {\n    int x = 10; // Allocated on the stack\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"heap-memory",children:"Heap Memory"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Manually managed by the programmer using malloc, calloc, realloc, and free."}),"\n",(0,a.jsx)(n.li,{children:"Used for dynamic memory allocation."}),"\n",(0,a.jsx)(n.li,{children:"Larger space but slower access than stack."}),"\n",(0,a.jsx)(n.li,{children:"Must be freed manually, or memory leaks occur."}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"example-1",children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"#include <stdlib.h>\nint main() {\n    int *ptr = (int *)malloc(sizeof(int)); // Allocated on the heap\n    free(ptr); // Must be freed\n    return 0;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"when-to-use-dynamic-vs-static-allocation",children:"When to Use Dynamic vs. Static Allocation"}),"\n",(0,a.jsx)(n.h3,{id:"23-when-to-use-dynamic-vs-static-allocation",children:(0,a.jsx)(n.strong,{children:"2.3 When to Use Dynamic vs. Static Allocation"})}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Feature"}),(0,a.jsx)(n.th,{children:"Stack (Static Allocation)"}),(0,a.jsx)(n.th,{children:"Heap (Dynamic Allocation)"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Memory Size"}),(0,a.jsx)(n.td,{children:"Fixed at compile-time"}),(0,a.jsx)(n.td,{children:"Flexible, allocated at runtime"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Management"}),(0,a.jsx)(n.td,{children:"Automatic"}),(0,a.jsxs)(n.td,{children:["Manual (",(0,a.jsx)(n.code,{children:"malloc/free"}),")"]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Speed"}),(0,a.jsx)(n.td,{children:"Faster"}),(0,a.jsx)(n.td,{children:"Slower"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Use Case"}),(0,a.jsx)(n.td,{children:"Local variables, function calls"}),(0,a.jsx)(n.td,{children:"Large data structures, variable-sized memory"})]})]})]}),"\n",(0,a.jsx)(n.h2,{id:"memory-allocation-functions",children:"Memory Allocation Functions"}),"\n",(0,a.jsx)(n.h3,{id:"malloc--allocates-memory-without-initialization",children:"malloc() \u2013 Allocates Memory Without Initialization"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Allocates uninitialized memory on the heap."}),"\n",(0,a.jsx)(n.li,{children:"Returns a pointer to the allocated memory."}),"\n",(0,a.jsx)(n.li,{children:"Must be explicitly freed using free()."}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:'#include <stdio.h>\n#include <stdlib.h>\nint main() {\n    int *ptr = (int *)malloc(5 * sizeof(int));\n    if (ptr == NULL) {\n        printf("Memory allocation failed\\n");\n        return 1;\n    }\n    ptr[0] = 42; // Assigning value\n    free(ptr); // Freeing memory\n    return 0;\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"calloc--allocates-and-initializes-memory-to-zero",children:"calloc() \u2013 Allocates and Initializes Memory to Zero"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"calloc"})," initializes all elements to zero."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"int *arr = (int *)calloc(5, sizeof(int));\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"calloc(n, size)"})," allocates n elements of size bytes each and initializes them to zero."]})}),"\n",(0,a.jsx)(n.h3,{id:"realloc--resizing-allocated-memory",children:"realloc() \u2013 Resizing Allocated Memory"}),"\n",(0,a.jsx)(n.p,{children:"Expands or shrinks an allocated block dynamically."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"arr = (int *)realloc(arr, 10 * sizeof(int));\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"realloc(ptr, new_size)"})," resizes previously allocated memory."]})}),"\n",(0,a.jsx)(n.h3,{id:"free--deallocates-memory",children:"free() \u2013 Deallocates Memory"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Releases memory back to the system."}),"\n",(0,a.jsx)(n.li,{children:"Avoids memory leaks."}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"free(arr);\narr = NULL; // Prevents dangling pointer\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices-for-memory-management",children:"Best Practices for Memory Management"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Always check if ",(0,a.jsx)(n.code,{children:"malloc"})," or ",(0,a.jsx)(n.code,{children:"calloc"})," returns NULL (allocation failure)."]}),"\n",(0,a.jsx)(n.li,{children:"Always free allocated memory once it's no longer needed."}),"\n",(0,a.jsxs)(n.li,{children:["Use ",(0,a.jsx)(n.code,{children:"realloc()"})," cautiously \u2013 if it returns NULL, old memory is lost."]}),"\n",(0,a.jsxs)(n.li,{children:["Set pointers to NULL after ",(0,a.jsx)(n.code,{children:"free()"})," to prevent dangling pointers."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"common-heap-memory-issues",children:"Common Heap Memory Issues"}),"\n",(0,a.jsx)(n.h3,{id:"memory-leaks",children:"Memory Leaks"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Cause: Forgetting to free allocated memory."}),"\n",(0,a.jsx)(n.li,{children:"Solution: Always call free() when done using memory."}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"int *ptr = (int *)malloc(sizeof(int));\n// Forgot to free(ptr); -> Memory leak!\n"})}),"\n",(0,a.jsx)(n.h3,{id:"dangling-pointers",children:"Dangling Pointers"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Cause: Using memory after freeing it."}),"\n",(0,a.jsx)(n.li,{children:"Solution: Set pointer to NULL after free()."}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:'free(ptr);\nprintf("%d", *ptr); // Undefined behavior!\n'})}),"\n",(0,a.jsx)(n.h3,{id:"double-free",children:"Double Free"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Cause: Calling free() twice on the same memory."}),"\n",(0,a.jsx)(n.li,{children:"Solution: Set pointer to NULL after freeing."}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"free(ptr);\nfree(ptr); // ERROR: Double free!\n"})}),"\n",(0,a.jsx)(n.h3,{id:"buffer-overflows",children:"Buffer Overflows"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Cause: Writing beyond allocated memory."}),"\n",(0,a.jsx)(n.li,{children:"Solution: Always allocate sufficient memory."}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"int *arr = (int *)malloc(5 * sizeof(int));\narr[6] = 42; // ERROR: Out of bounds\n"})}),"\n",(0,a.jsx)(n.h2,{id:"debugging-tools-for-memory-management",children:"Debugging Tools for Memory Management"}),"\n",(0,a.jsx)(n.h3,{id:"using-valgrind-linux",children:"Using valgrind (Linux)"}),"\n",(0,a.jsx)(n.p,{children:"Detects memory leaks and invalid memory accesses."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"valgrind --leak-check=full ./a.out\n"})}),"\n",(0,a.jsx)(n.h3,{id:"using-address-sanitizer-gccclang",children:"Using Address Sanitizer (GCC/Clang)"}),"\n",(0,a.jsx)(n.p,{children:"Compile with:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"gcc -fsanitize=address -g program.c -o program\n"})})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,l)=>{l.d(n,{R:()=>r,x:()=>s});var i=l(6540);const a={},o=i.createContext(a);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);