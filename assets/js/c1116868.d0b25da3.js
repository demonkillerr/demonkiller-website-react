"use strict";(self.webpackChunkdemonkiller_portfolio=self.webpackChunkdemonkiller_portfolio||[]).push([[3137],{599:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"code/languages/C/arrays_and_pointers","title":"Arrays and Pointers","description":"This document covers the relation between Arrays and Pointers in C.","source":"@site/docs/code/languages/C/arrays_and_pointers.md","sourceDirName":"code/languages/C","slug":"/code/languages/C/arrays_and_pointers","permalink":"/docs/code/languages/C/arrays_and_pointers","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"Gaurang","lastUpdatedAt":1739855289000,"frontMatter":{"title":"Arrays and Pointers","id":"arrays_and_pointers","sidebar_label":"Arrays & Pointers"},"sidebar":"docs","previous":{"title":"Arrays","permalink":"/docs/code/languages/C/arrays"},"next":{"title":"Arrays of Pointers","permalink":"/docs/code/languages/C/arrays_of_pointers"}}');var a=i(4848),t=i(8453);const s={title:"Arrays and Pointers",id:"arrays_and_pointers",sidebar_label:"Arrays & Pointers"},o=void 0,l={},d=[{value:"Relationship Between Arrays and Pointers",id:"relationship-between-arrays-and-pointers",level:2},{value:"Example: Understanding Array-Pointer Equivalence",id:"example-understanding-array-pointer-equivalence",level:4},{value:"Pointer Arithmetic with Arrays",id:"pointer-arithmetic-with-arrays",level:2},{value:"Example: Iterating Using Pointer Arithmetic",id:"example-iterating-using-pointer-arithmetic",level:4},{value:"Passing Arrays to Functions Using Pointers",id:"passing-arrays-to-functions-using-pointers",level:2},{value:"Example: Function That Modifies an Array",id:"example-function-that-modifies-an-array",level:4},{value:"Dynamic Memory Allocation",id:"dynamic-memory-allocation",level:2},{value:"Allocating Memory with malloc",id:"allocating-memory-with-malloc",level:3},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Pointer Decay",id:"pointer-decay",level:3},{value:"Solution:",id:"solution",level:4},{value:"Memory Leaks",id:"memory-leaks",level:3},{value:"Solution:",id:"solution-1",level:4},{value:"Dangling Pointers",id:"dangling-pointers",level:3},{value:"Solution:",id:"solution-2",level:4},{value:"Dynamic Memory allocation has been described in depth in the next chapter.",id:"dynamic-memory-allocation-has-been-described-in-depth-in-the-next-chapter",level:4}];function c(e){const n={admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"This document covers the relation between Arrays and Pointers in C."}),"\n",(0,a.jsx)(n.p,{children:"Arrays and pointers are closely related in C. An array name acts as a pointer to its first element, enabling efficient memory access and manipulation. Understanding this relationship is crucial for working with dynamic memory allocation and passing arrays to functions."}),"\n",(0,a.jsx)(n.p,{children:"In this section, we will cover:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"How arrays and pointers relate."}),"\n",(0,a.jsx)(n.li,{children:"Pointer arithmetic with arrays."}),"\n",(0,a.jsx)(n.li,{children:"Passing arrays to functions using pointers."}),"\n",(0,a.jsx)(n.li,{children:"Dynamic memory allocation (malloc, calloc, free)."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"relationship-between-arrays-and-pointers",children:"Relationship Between Arrays and Pointers"}),"\n",(0,a.jsx)(n.p,{children:"An array name acts as a constant pointer to its first element. This means:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"arr"})," and ",(0,a.jsx)(n.code,{children:"&arr[0]"})," hold the same address."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"*(arr + i)"})," is equivalent to ",(0,a.jsx)(n.code,{children:"arr[i]"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"example-understanding-array-pointer-equivalence",children:"Example: Understanding Array-Pointer Equivalence"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:'#include <stdio.h>\nint main() {\n    int arr[] = {10, 20, 30};\n    printf("Address of arr: %p\\n", arr);\n    printf("Address of arr[0]: %p\\n", &arr[0]);\n    printf("First element using pointer: %d\\n", *arr);\n    return 0;\n}\n'})}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"arr"})," gives the address of the first element."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"*arr"})," accesses the first element."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"arr + 1"})," moves to the next element."]}),"\n"]})}),"\n",(0,a.jsx)(n.h2,{id:"pointer-arithmetic-with-arrays",children:"Pointer Arithmetic with Arrays"}),"\n",(0,a.jsx)(n.p,{children:"Since arrays are stored in contiguous memory locations, pointers can be used to traverse them."}),"\n",(0,a.jsx)(n.h4,{id:"example-iterating-using-pointer-arithmetic",children:"Example: Iterating Using Pointer Arithmetic"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:'#include <stdio.h>\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int *ptr = arr;\n    for (int i = 0; i < 5; i++) {\n        printf("Element %d: %d\\n", i, *(ptr + i));\n    }\n    return 0;\n}\n'})}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"ptr + i"})," moves the pointer forward by i elements. ",(0,a.jsx)(n.code,{children:"*(ptr + i)"})," retrieves the element at that position."]})}),"\n",(0,a.jsx)(n.h2,{id:"passing-arrays-to-functions-using-pointers",children:"Passing Arrays to Functions Using Pointers"}),"\n",(0,a.jsx)(n.p,{children:"When passing an array to a function, what is actually passed is a pointer to its first element."}),"\n",(0,a.jsx)(n.h4,{id:"example-function-that-modifies-an-array",children:"Example: Function That Modifies an Array"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:'#include <stdio.h>\nvoid modifyArray(int *arr, int size) {\n    for (int i = 0; i < size; i++) {\n        arr[i] *= 2; // Modifies original array\n    }\n}\n\nint main() {\n    int numbers[] = {1, 2, 3, 4, 5};\n    int size = sizeof(numbers) / sizeof(numbers[0]);\n    modifyArray(numbers, size);\n    for (int i = 0; i < size; i++) {\n        printf("%d ", numbers[i]);\n    }\n    return 0;\n}\n'})}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Why does this work?"})," Arrays are passed as pointers, meaning the function modifies the original array."]})}),"\n",(0,a.jsx)(n.h2,{id:"dynamic-memory-allocation",children:"Dynamic Memory Allocation"}),"\n",(0,a.jsx)(n.p,{children:"C allows dynamic allocation of memory at runtime using malloc, calloc, and free. This section just covers it in brief."}),"\n",(0,a.jsx)(n.h3,{id:"allocating-memory-with-malloc",children:"Allocating Memory with malloc"}),"\n",(0,a.jsx)(n.p,{children:"Allocates a block of memory without initializing it."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:'#include <stdio.h>\n#include <stdlib.h>\nint main() {\n    int *arr = (int *)malloc(5 * sizeof(int));\n    if (arr == NULL) {\n        printf("Memory allocation failed\\n");\n        return 1;\n    }\n    for (int i = 0; i < 5; i++) {\n        arr[i] = i + 1;\n    }\n    free(arr); // Free allocated memory\n    return 0;\n}\n'})}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"malloc(size)"})," allocates size bytes of memory."]}),"\n",(0,a.jsxs)(n.li,{children:["Always use ",(0,a.jsx)(n.code,{children:"free(ptr)"})," to avoid memory leaks."]}),"\n"]})}),"\n",(0,a.jsx)(n.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,a.jsx)(n.h3,{id:"pointer-decay",children:"Pointer Decay"}),"\n",(0,a.jsx)(n.p,{children:"Arrays decay into pointers when passed to functions, losing their size information."}),"\n",(0,a.jsx)(n.h4,{id:"solution",children:"Solution:"}),"\n",(0,a.jsx)(n.p,{children:"Always pass the array size explicitly."}),"\n",(0,a.jsx)(n.h3,{id:"memory-leaks",children:"Memory Leaks"}),"\n",(0,a.jsx)(n.p,{children:"Failing to free dynamically allocated memory causes memory leaks."}),"\n",(0,a.jsx)(n.h4,{id:"solution-1",children:"Solution:"}),"\n",(0,a.jsxs)(n.p,{children:["Use ",(0,a.jsx)(n.code,{children:"free(ptr)"})," after you're done with allocated memory."]}),"\n",(0,a.jsx)(n.h3,{id:"dangling-pointers",children:"Dangling Pointers"}),"\n",(0,a.jsx)(n.p,{children:"Accessing freed memory results in undefined behavior."}),"\n",(0,a.jsx)(n.h4,{id:"solution-2",children:"Solution:"}),"\n",(0,a.jsxs)(n.p,{children:["Set pointers to NULL after ",(0,a.jsx)(n.code,{children:"free()"}),"."]}),"\n",(0,a.jsx)(n.h4,{id:"dynamic-memory-allocation-has-been-described-in-depth-in-the-next-chapter",children:"Dynamic Memory allocation has been described in depth in the next chapter."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>o});var r=i(6540);const a={},t=r.createContext(a);function s(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);