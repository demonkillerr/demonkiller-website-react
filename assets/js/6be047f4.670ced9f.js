"use strict";(self.webpackChunkdemonkiller_portfolio=self.webpackChunkdemonkiller_portfolio||[]).push([[7781],{3649:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"code/languages/C/pointers","title":"Pointers in C","description":"This document covers Pointers in C.","source":"@site/docs/code/languages/C/pointers.md","sourceDirName":"code/languages/C","slug":"/code/languages/C/pointers","permalink":"/docs/code/languages/C/pointers","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"Gaurang","lastUpdatedAt":1739855289000,"frontMatter":{"title":"Pointers in C","id":"pointers","sidebar_label":"Pointers"},"sidebar":"docs","previous":{"title":"Recursion","permalink":"/docs/code/languages/C/recursion"},"next":{"title":"Pointer to Functions","permalink":"/docs/code/languages/C/pointer_to_function"}}');var t=i(4848),s=i(8453);const o={title:"Pointers in C",id:"pointers",sidebar_label:"Pointers"},l=void 0,a={},d=[{value:"What is a Pointer?",id:"what-is-a-pointer",level:2},{value:"Declaring a Pointer",id:"declaring-a-pointer",level:3},{value:"Assigning an Address to a Pointer",id:"assigning-an-address-to-a-pointer",level:3},{value:"Example",id:"example",level:4},{value:"<code>const</code> with Pointers",id:"const-with-pointers",level:3},{value:"Example",id:"example-1",level:4},{value:"NULL Pointers",id:"null-pointers",level:2},{value:"Why Use NULL Pointers?",id:"why-use-null-pointers",level:3},{value:"Checking for NULL Before Dereferencing",id:"checking-for-null-before-dereferencing",level:3},{value:"Example",id:"example-2",level:4},{value:"Pointer Arithmetic",id:"pointer-arithmetic",level:2},{value:"Incrementing and Decrementing Pointers",id:"incrementing-and-decrementing-pointers",level:3},{value:"Example",id:"example-3",level:4},{value:"Pointer Arithmetic with Arrays",id:"pointer-arithmetic-with-arrays",level:3},{value:"Example",id:"example-4",level:4},{value:"Common Pointer-Related Problems",id:"common-pointer-related-problems",level:2},{value:"Memory Leaks",id:"memory-leaks",level:3},{value:"Solution:",id:"solution",level:4},{value:"Dangling Pointers",id:"dangling-pointers",level:3},{value:"Solution",id:"solution-1",level:4},{value:"Pointer Arithmetic Errors",id:"pointer-arithmetic-errors",level:3},{value:"Solution",id:"solution-2",level:4},{value:"Stack Overflow Due to Excessive Recursion",id:"stack-overflow-due-to-excessive-recursion",level:3},{value:"Solution",id:"solution-3",level:4}];function c(e){const n={admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"This document covers Pointers in C."}),"\n",(0,t.jsx)(n.p,{children:"Pointers are one of the most powerful features of the C programming language. They allow direct memory access, making programs efficient but also prone to errors if not handled correctly. Understanding pointers is essential for low-level programming, memory management, and optimizing performance."}),"\n",(0,t.jsx)(n.p,{children:"In this section, we will cover:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"What a pointer is and how it works."}),"\n",(0,t.jsx)(n.li,{children:"NULL pointers and their significance."}),"\n",(0,t.jsx)(n.li,{children:"Dereferencing and using & (address-of) and * (dereference) operators."}),"\n",(0,t.jsx)(n.li,{children:"Pointer arithmetic and how pointers interact with arrays."}),"\n",(0,t.jsx)(n.li,{children:"Common pointer-related problems, including memory leaks and stack overflows."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"what-is-a-pointer",children:"What is a Pointer?"}),"\n",(0,t.jsx)(n.p,{children:"A pointer is a variable that stores the memory address of another variable. Instead of holding a direct value, it holds the location where the value is stored."}),"\n",(0,t.jsx)(n.h3,{id:"declaring-a-pointer",children:"Declaring a Pointer"}),"\n",(0,t.jsx)(n.p,{children:"A pointer is declared using the * operator."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"int *ptr;  // Declares a pointer to an integer\n"})}),"\n",(0,t.jsx)(n.h3,{id:"assigning-an-address-to-a-pointer",children:"Assigning an Address to a Pointer"}),"\n",(0,t.jsx)(n.p,{children:"We use the address-of (&) operator to get the address of a variable and assign it to a pointer.\\"}),"\n",(0,t.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'#include <stdio.h>\nint main() {\n    int num = 10;\n    int *ptr = &num;  // Pointer stores the address of num\n    printf("Address of num: %p\\n", ptr);\n    printf("Value of num using pointer: %d\\n", *ptr);\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"&num"})," gives the memory address of num."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"ptr stores this address."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"*ptr"})," (dereferencing) retrieves the value stored at that address."]}),"\n"]}),"\n"]})}),"\n",(0,t.jsxs)(n.h3,{id:"const-with-pointers",children:[(0,t.jsx)(n.code,{children:"const"})," with Pointers"]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:(0,t.jsx)(n.strong,{children:"Declaration"})}),(0,t.jsx)(n.th,{children:(0,t.jsx)(n.strong,{children:"Meaning"})})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"const int *ptr"})}),(0,t.jsx)(n.td,{children:"Pointer to a constant integer (cannot modify the value)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"int *const ptr"})}),(0,t.jsx)(n.td,{children:"Constant pointer to an integer (cannot change the pointer address)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"const int *const ptr"})}),(0,t.jsx)(n.td,{children:"Constant pointer to a constant integer (neither value nor address can change)"})]})]})]}),"\n",(0,t.jsx)(n.h4,{id:"example-1",children:"Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"const int value = 10;\nconst int *ptr = &value;  // Pointer to a constant integer\n*ptr = 20;  // Error: Cannot modify the value\n"})}),"\n",(0,t.jsx)(n.h2,{id:"null-pointers",children:"NULL Pointers"}),"\n",(0,t.jsx)(n.p,{children:"A NULL pointer is a pointer that does not point to any valid memory location."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"int *ptr = NULL;  // Pointer initialized to NULL\n"})}),"\n",(0,t.jsx)(n.h3,{id:"why-use-null-pointers",children:"Why Use NULL Pointers?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Prevents accessing uninitialized pointers."}),"\n",(0,t.jsx)(n.li,{children:"Can be used to check if memory allocation was successful."}),"\n",(0,t.jsx)(n.li,{children:"Helps avoid undefined behavior in programs."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"checking-for-null-before-dereferencing",children:"Checking for NULL Before Dereferencing"}),"\n",(0,t.jsx)(n.admonition,{type:"danger",children:(0,t.jsx)(n.p,{children:"Dereferencing a NULL pointer causes a segmentation fault. Always check before dereferencing:"})}),"\n",(0,t.jsx)(n.h4,{id:"example-2",children:"Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'#include <stdio.h>\nint main() {\n    int *ptr = NULL;\n    if (ptr == NULL) {\n        printf("Pointer is NULL, cannot dereference\\n");\n    }\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"pointer-arithmetic",children:"Pointer Arithmetic"}),"\n",(0,t.jsx)(n.h3,{id:"incrementing-and-decrementing-pointers",children:"Incrementing and Decrementing Pointers"}),"\n",(0,t.jsx)(n.p,{children:"Pointers can be incremented or decremented to traverse memory locations."}),"\n",(0,t.jsx)(n.h4,{id:"example-3",children:"Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'#include <stdio.h>\nint main() {\n    int arr[3] = {10, 20, 30};\n    int *ptr = arr;  // Points to the first element\n    printf("First element: %d\\n", *ptr);\n    ptr++;  // Moves to the next element\n    printf("Second element: %d\\n", *ptr);\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"ptr++ moves the pointer to the next element in the array."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"ptr-- moves the pointer back."}),"\n"]}),"\n"]})}),"\n",(0,t.jsx)(n.h3,{id:"pointer-arithmetic-with-arrays",children:"Pointer Arithmetic with Arrays"}),"\n",(0,t.jsx)(n.p,{children:"Pointers and arrays are closely related. An array name is a pointer to its first element."}),"\n",(0,t.jsx)(n.h4,{id:"example-4",children:"Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'#include <stdio.h>\nint main() {\n    int arr[3] = {10, 20, 30};\n    int *ptr = arr;\n    for (int i = 0; i < 3; i++) {\n        printf("Element %d: %d\\n", i, *(ptr + i));\n    }\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"ptr + i"})," moves the pointer to different elements in the array."]})}),"\n",(0,t.jsx)(n.h2,{id:"common-pointer-related-problems",children:"Common Pointer-Related Problems"}),"\n",(0,t.jsx)(n.h3,{id:"memory-leaks",children:"Memory Leaks"}),"\n",(0,t.jsx)(n.p,{children:"Memory leaks occur when dynamically allocated memory is not freed."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"#include <stdlib.h>\nint main() {\n    int *ptr = (int *)malloc(sizeof(int));\n    *ptr = 42;\n    // Forgot to free memory: memory leak occurs\n    return 0;\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"solution",children:"Solution:"}),"\n",(0,t.jsx)(n.p,{children:"Solution: Always free dynamically allocated memory."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"free(ptr);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"dangling-pointers",children:"Dangling Pointers"}),"\n",(0,t.jsx)(n.p,{children:"A dangling pointer points to memory that has been freed."}),"\n",(0,t.jsx)(n.h4,{id:"solution-1",children:"Solution"}),"\n",(0,t.jsx)(n.p,{children:"Set the pointer to NULL after freeing it."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"free(ptr);\nptr = NULL;\n"})}),"\n",(0,t.jsx)(n.h3,{id:"pointer-arithmetic-errors",children:"Pointer Arithmetic Errors"}),"\n",(0,t.jsx)(n.p,{children:"Incorrect pointer arithmetic can lead to out-of-bounds access."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'int arr[3] = {1, 2, 3};\nint *ptr = arr;\nprintf("Out-of-bounds access: %d\\n", *(ptr + 5)); // Undefined behavior\n'})}),"\n",(0,t.jsx)(n.h4,{id:"solution-2",children:"Solution"}),"\n",(0,t.jsx)(n.p,{children:"Always check pointer bounds before accessing memory."}),"\n",(0,t.jsx)(n.h3,{id:"stack-overflow-due-to-excessive-recursion",children:"Stack Overflow Due to Excessive Recursion"}),"\n",(0,t.jsx)(n.p,{children:"Using pointers in recursion without an exit condition can cause a stack overflow."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"void recursiveFunction() {\n    int num;\n    recursiveFunction();  // No exit condition: leads to stack overflow\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"solution-3",children:"Solution"}),"\n",(0,t.jsx)(n.p,{children:"Ensure a base case in recursive functions."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var r=i(6540);const t={},s=r.createContext(t);function o(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);