"use strict";(self.webpackChunkdemonkiller_portfolio=self.webpackChunkdemonkiller_portfolio||[]).push([[334],{927:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"code/languages/C/dynamic_data_structures","title":"Dynamic Data Structures in C","description":"This document covers Dynamic Data Structures in C.","source":"@site/docs/code/languages/C/dynamic_data_structs.md","sourceDirName":"code/languages/C","slug":"/code/languages/C/dynamic_data_structures","permalink":"/docs/code/languages/C/dynamic_data_structures","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"demonkiller","lastUpdatedAt":1739852783000,"frontMatter":{"title":"Dynamic Data Structures in C","id":"dynamic_data_structures","sidebar_label":"Dynamic Data Structures"},"sidebar":"docs","previous":{"title":"Files I/O","permalink":"/docs/code/languages/C/fileio"},"next":{"title":"CLI & Signal Handling","permalink":"/docs/code/languages/C/cli_and_sighandle"}}');var r=i(4848),s=i(8453);const a={title:"Dynamic Data Structures in C",id:"dynamic_data_structures",sidebar_label:"Dynamic Data Structures"},d=void 0,l={},o=[{value:"Linked Lists",id:"linked-lists",level:2},{value:"Structure of a Node",id:"structure-of-a-node",level:3},{value:"Singly Linked List Operations",id:"singly-linked-list-operations",level:3},{value:"Insertion at the Beginning",id:"insertion-at-the-beginning",level:4},{value:"Deletion from the Beginning",id:"deletion-from-the-beginning",level:4},{value:"Doubly Linked List (With prev Pointer)",id:"doubly-linked-list-with-prev-pointer",level:3},{value:"Stacks &amp; Queues",id:"stacks--queues",level:2},{value:"Stack (LIFO - Last In First Out)",id:"stack-lifo---last-in-first-out",level:3},{value:"Using a Linked List",id:"using-a-linked-list",level:4},{value:"Using an Array",id:"using-an-array",level:4},{value:"Queue (FIFO - First In First Out)",id:"queue-fifo---first-in-first-out",level:3},{value:"Using a Linked List",id:"using-a-linked-list-1",level:4},{value:"Using a Circular Array",id:"using-a-circular-array",level:4},{value:"Binary Trees",id:"binary-trees",level:2},{value:"Structure of a Binary Tree Node",id:"structure-of-a-binary-tree-node",level:3},{value:"Insertion into a Binary Tree",id:"insertion-into-a-binary-tree",level:3}];function c(e){const n={admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"This document covers Dynamic Data Structures in C."}),"\n",(0,r.jsx)(n.p,{children:"Dynamic data structures allow efficient memory management and flexibility in handling data. Unlike static arrays, these structures can grow or shrink dynamically at runtime using pointers and dynamic memory allocation (malloc, free)."}),"\n",(0,r.jsx)(n.p,{children:"In this section, we will cover:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Linked Lists (Singly, Doubly, Circular)"}),"\n",(0,r.jsx)(n.li,{children:"Stacks & Queues (Using Linked Lists and Arrays)"}),"\n",(0,r.jsx)(n.li,{children:"Binary Trees (Basics, Insertion, Traversal)"}),"\n",(0,r.jsx)(n.li,{children:"Memory Management with malloc and free"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"linked-lists",children:"Linked Lists"}),"\n",(0,r.jsx)(n.p,{children:"A linked list consists of nodes, where each node contains data and a pointer to the next node."}),"\n",(0,r.jsx)(n.h3,{id:"structure-of-a-node",children:"Structure of a Node"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"struct Node {\n    int data;\n    struct Node *next;\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"singly-linked-list-operations",children:"Singly Linked List Operations"}),"\n",(0,r.jsx)(n.h4,{id:"insertion-at-the-beginning",children:"Insertion at the Beginning"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"#include <stdio.h>\n#include <stdlib.h>\nstruct Node {\n    int data;\n    struct Node* next;\n};\nvoid insertAtBeginning(struct Node** head, int newData) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = newData;\n    newNode->next = *head;\n    *head = newNode;\n}\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"Uses malloc() to dynamically allocate memory for new nodes."})}),"\n",(0,r.jsx)(n.h4,{id:"deletion-from-the-beginning",children:"Deletion from the Beginning"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"void deleteAtBeginning(struct Node** head) {\n    if (*head == NULL) return;\n    struct Node* temp = *head;\n    *head = (*head)->next;\n    free(temp);\n}\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"Uses free() to deallocate memory, preventing memory leaks."})}),"\n",(0,r.jsx)(n.h3,{id:"doubly-linked-list-with-prev-pointer",children:"Doubly Linked List (With prev Pointer)"}),"\n",(0,r.jsx)(n.p,{children:"A doubly linked list allows traversal in both directions."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"struct DNode {\n    int data;\n    struct DNode *prev, *next;\n};\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"Advantage: Easier to traverse backward compared to singly linked lists."})}),"\n",(0,r.jsx)(n.h2,{id:"stacks--queues",children:"Stacks & Queues"}),"\n",(0,r.jsx)(n.p,{children:"Stacks and queues are fundamental abstract data types (ADTs) used for managing ordered data."}),"\n",(0,r.jsx)(n.h3,{id:"stack-lifo---last-in-first-out",children:"Stack (LIFO - Last In First Out)"}),"\n",(0,r.jsx)(n.h4,{id:"using-a-linked-list",children:"Using a Linked List"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"struct StackNode {\n    int data;\n    struct StackNode* next;\n};\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Push (Insert at top)"}),"\n",(0,r.jsx)(n.li,{children:"Pop (Remove from top)"}),"\n"]})}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"Used in: Function calls (recursion), expression evaluation, undo operations."})}),"\n",(0,r.jsx)(n.h4,{id:"using-an-array",children:"Using an Array"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"#define MAX 100\nstruct Stack {\n    int top;\n    int arr[MAX];\n};\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"Advantage: Faster access but fixed size."})}),"\n",(0,r.jsx)(n.h3,{id:"queue-fifo---first-in-first-out",children:"Queue (FIFO - First In First Out)"}),"\n",(0,r.jsx)(n.h4,{id:"using-a-linked-list-1",children:"Using a Linked List"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"struct QueueNode {\n    int data;\n    struct QueueNode* next;\n};\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Enqueue (Insert at rear)"}),"\n",(0,r.jsx)(n.li,{children:"Dequeue (Remove from front)"}),"\n"]})}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"Used in: Scheduling (CPU, Printer), Buffering."})}),"\n",(0,r.jsx)(n.h4,{id:"using-a-circular-array",children:"Using a Circular Array"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"#define SIZE 10\nstruct Queue {\n    int front, rear;\n    int arr[SIZE];\n};\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"Advantage: Avoids shifting elements."})}),"\n",(0,r.jsx)(n.h2,{id:"binary-trees",children:"Binary Trees"}),"\n",(0,r.jsx)(n.p,{children:"A binary tree is a hierarchical structure where each node has at most two children."}),"\n",(0,r.jsx)(n.h3,{id:"structure-of-a-binary-tree-node",children:"Structure of a Binary Tree Node"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"struct TreeNode {\n    int data;\n    struct TreeNode *left, *right;\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"insertion-into-a-binary-tree",children:"Insertion into a Binary Tree"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"#include <stdio.h>\n#include <stdlib.h>\nstruct TreeNode {\n    int data;\n    struct TreeNode* left;\n    struct TreeNode* right;\n};\nstruct TreeNode* insertNode(struct TreeNode* root, int value) {\n    if (root == NULL) {\n        root = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n        root->data = value;\n        root->left = root->right = NULL;\n    } else if (value < root->data) {\n        root->left = insertNode(root->left, value);\n    } else {\n        root->right = insertNode(root->right, value);\n    }\n    return root;\n}\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"Key Points: Uses recursion for insertion, dynamically allocates nodes."})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>d});var t=i(6540);const r={},s=t.createContext(r);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);