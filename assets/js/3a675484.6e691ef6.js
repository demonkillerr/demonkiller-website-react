"use strict";(self.webpackChunkdemonkiller_portfolio=self.webpackChunkdemonkiller_portfolio||[]).push([[4585],{2044:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>c,metadata:()=>s,toc:()=>t});const s=JSON.parse('{"id":"code/languages/C/recursion","title":"Recursive Functions","description":"This document covers recursion in C.","source":"@site/docs/code/languages/C/recursion.md","sourceDirName":"code/languages/C","slug":"/code/languages/C/recursion","permalink":"/docs/code/languages/C/recursion","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"demonkiller","lastUpdatedAt":1739829515000,"frontMatter":{"title":"Recursive Functions","id":"recursion","sidebar_label":"Recursion"},"sidebar":"docs","previous":{"title":"Functions","permalink":"/docs/code/languages/C/functions"},"next":{"title":"Pointers","permalink":"/docs/code/languages/C/pointers"}}');var r=i(4848),a=i(8453);const c={title:"Recursive Functions",id:"recursion",sidebar_label:"Recursion"},o=void 0,l={},t=[{value:"How Recursion Works",id:"how-recursion-works",level:2},{value:"Structure of a Recursive Function",id:"structure-of-a-recursive-function",level:3},{value:"Example",id:"example",level:4},{value:"Examples of Recursive Functions",id:"examples-of-recursive-functions",level:2},{value:"Factorial Calculation",id:"factorial-calculation",level:3},{value:"Fibonacci Series",id:"fibonacci-series",level:3},{value:"Binary Search (Recursive Implementation)",id:"binary-search-recursive-implementation",level:3},{value:"Advantages and Disadvantages of Recursion",id:"advantages-and-disadvantages-of-recursion",level:2},{value:"Advantages",id:"advantages",level:3},{value:"Disadvantages",id:"disadvantages",level:3},{value:"Common Pitfalls and Stack Overflow",id:"common-pitfalls-and-stack-overflow",level:2},{value:"Missing Base Case",id:"missing-base-case",level:3},{value:"Solution",id:"solution",level:5},{value:"Excessive Function Calls (Inefficient Recursion)",id:"excessive-function-calls-inefficient-recursion",level:3}];function d(n){const e={admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.p,{children:"This document covers recursion in C."}),"\n",(0,r.jsx)(e.p,{children:"Recursion is a powerful concept in programming where a function calls itself to solve a problem. In C, recursion is used for problems that can be broken down into smaller subproblems, making the code more elegant and easier to understand."}),"\n",(0,r.jsx)(e.p,{children:"In this section, we will cover:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"What recursion is and how it works."}),"\n",(0,r.jsx)(e.li,{children:"Base case and recursive case."}),"\n",(0,r.jsx)(e.li,{children:"Examples of recursion (Factorial, Fibonacci, and Binary Search)."}),"\n",(0,r.jsx)(e.li,{children:"Pros and cons of recursion."}),"\n",(0,r.jsx)(e.li,{children:"Common pitfalls, including stack overflow."}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"how-recursion-works",children:"How Recursion Works"}),"\n",(0,r.jsx)(e.p,{children:"A recursive function is a function that calls itself with modified parameters until a stopping condition (base case) is met."}),"\n",(0,r.jsx)(e.h3,{id:"structure-of-a-recursive-function",children:"Structure of a Recursive Function"}),"\n",(0,r.jsx)(e.p,{children:"A recursive function consists of two parts:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Base Case \u2013 Defines when the recursion should stop."}),"\n",(0,r.jsx)(e.li,{children:"Recursive Case \u2013 Calls itself with modified arguments."}),"\n"]}),"\n",(0,r.jsx)(e.h4,{id:"example",children:"Example"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-c",children:'#include <stdio.h>\nvoid countdown(int n) {\n    if (n == 0) { // Base case\n        printf("Blast off!\\n");\n        return;\n    }\n    printf("%d\\n", n);\n    countdown(n - 1); // Recursive call\n}\n\nint main() {\n    countdown(5);\n    return 0;\n}\n'})}),"\n",(0,r.jsx)(e.admonition,{type:"info",children:(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"Base case: Stops when n == 0."}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"Recursive case: Calls countdown(n - 1)."}),"\n"]}),"\n"]})}),"\n",(0,r.jsx)(e.h2,{id:"examples-of-recursive-functions",children:"Examples of Recursive Functions"}),"\n",(0,r.jsx)(e.h3,{id:"factorial-calculation",children:"Factorial Calculation"}),"\n",(0,r.jsx)(e.p,{children:"Factorial of n is defined as n! = n \xd7 (n-1)!"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-c",children:'#include <stdio.h>\nint factorial(int n) {\n    if (n == 0) return 1; // Base case\n    return n * factorial(n - 1); // Recursive case\n}\n\nint main() {\n    int num = 5;\n    printf("Factorial of %d is %d\\n", num, factorial(num));\n    return 0;\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"fibonacci-series",children:"Fibonacci Series"}),"\n",(0,r.jsx)(e.p,{children:"Each Fibonacci number is the sum of the two preceding numbers."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-c",children:'#include <stdio.h>\nint fibonacci(int n) {\n    if (n == 0) return 0; // Base case\n    if (n == 1) return 1; // Base case\n    return fibonacci(n - 1) + fibonacci(n - 2); // Recursive case\n}\n\nint main() {\n    int num = 6;\n    printf("Fibonacci(%d) = %d\\n", num, fibonacci(num));\n    return 0;\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"binary-search-recursive-implementation",children:"Binary Search (Recursive Implementation)"}),"\n",(0,r.jsx)(e.p,{children:"Binary search efficiently finds an element in a sorted array by repeatedly dividing the search range in half."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-c",children:'#include <stdio.h>\nint binarySearch(int arr[], int low, int high, int key) {\n    if (low > high) return -1; // Base case: Element not found\n    \n    int mid = low + (high - low) / 2;\n    if (arr[mid] == key) return mid;\n    else if (arr[mid] > key) return binarySearch(arr, low, mid - 1, key);\n    else return binarySearch(arr, mid + 1, high, key);\n}\n\nint main() {\n    int arr[] = {1, 3, 5, 7, 9, 11};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int key = 5;\n    int index = binarySearch(arr, 0, size - 1, key);\n    if (index != -1) printf("Element found at index %d\\n", index);\n    else printf("Element not found\\n");\n    return 0;\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"advantages-and-disadvantages-of-recursion",children:"Advantages and Disadvantages of Recursion"}),"\n",(0,r.jsx)(e.h3,{id:"advantages",children:"Advantages"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Makes complex problems easier to understand."}),"\n",(0,r.jsx)(e.li,{children:"Reduces code duplication by using a cleaner, more modular approach."}),"\n",(0,r.jsx)(e.li,{children:"Natural fit for problems that can be broken down into smaller subproblems."}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"disadvantages",children:"Disadvantages"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Recursion can be inefficient due to repeated function calls."}),"\n",(0,r.jsx)(e.li,{children:"May cause stack overflow if the recursion depth is too large."}),"\n",(0,r.jsx)(e.li,{children:"Uses more memory compared to iteration."}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"common-pitfalls-and-stack-overflow",children:"Common Pitfalls and Stack Overflow"}),"\n",(0,r.jsx)(e.h3,{id:"missing-base-case",children:"Missing Base Case"}),"\n",(0,r.jsx)(e.p,{children:"If a recursive function does not have a proper base case, it will continue calling itself indefinitely, causing a stack overflow."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-c",children:'void infiniteRecursion() {\n    printf("This will never stop!\\n");\n    infiniteRecursion(); // No base case!\n}\n'})}),"\n",(0,r.jsx)(e.h5,{id:"solution",children:"Solution"}),"\n",(0,r.jsx)(e.p,{children:"Always define a base case to stop recursion."}),"\n",(0,r.jsx)(e.h3,{id:"excessive-function-calls-inefficient-recursion",children:"Excessive Function Calls (Inefficient Recursion)"}),"\n",(0,r.jsx)(e.p,{children:"Some recursive functions, like the naive Fibonacci implementation, recompute values multiple times."})]})}function u(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>c,x:()=>o});var s=i(6540);const r={},a=s.createContext(r);function c(n){const e=s.useContext(a);return s.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:c(n.components),s.createElement(a.Provider,{value:e},n.children)}}}]);